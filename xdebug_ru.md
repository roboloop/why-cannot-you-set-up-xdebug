# Конфигурация Xdebug

<!-- toc -->

- [Проблематика](#%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)
- [Принцип работы](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B)
  * [Web-приложение](#web-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
    + [Триггер](#%D1%82%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80)
    + [Проверка триггера](#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D1%82%D1%80%D0%B8%D0%B3%D0%B3%D0%B5%D1%80%D0%B0)
    + [Поиск адреса клиента и соединение](#%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0-%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%B0-%D0%B8-%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
    + [Общение с клиентом](#%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81-%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%BE%D0%BC)
    + [Завершение сессии](#%D0%B7%D0%B0%D0%B2%D0%B5%D1%80%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%B5%D1%81%D1%81%D0%B8%D0%B8)
  * [CLI-приложение](#cli-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)
  * [Проксирование](#%D0%BF%D1%80%D0%BE%D0%BA%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
    + [DBGp Proxy](#dbgp-proxy)
    + [Xdebug Cloud](#xdebug-cloud)
- [Конфигурация](#%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F)
  * [Универсальная конфигурация Xdebug](#%D1%83%D0%BD%D0%B8%D0%B2%D0%B5%D1%80%D1%81%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F-xdebug)
    + [Local](#local)
    + [Vagrant](#vagrant)
    + [Docker](#docker)
  * [Особенности настройки в PhpStorm](#%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B2-PhpStorm)
    + [Запуск скриптов из IDE](#%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B2-%D0%B8%D0%B7-ide)
    + [Обработка запросов пришедших в IDE](#%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%BE%D0%B2-%D0%BF%D1%80%D0%B8%D1%88%D0%B5%D0%B4%D1%88%D0%B8%D1%85-%D0%B2-ide)
- [Частые проблемы](#%D1%87%D0%B0%D1%81%D1%82%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D1%8B)
  * [Как инспектировать?](#%D0%BA%D0%B0%D0%BA-%D0%B8%D0%BD%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C)
  * [Cannot find file '/var/www/ez-project/index.php' locally](#cannot-find-file-varwwwez-projectindexphp-locally)
  * [Как запустить из CLI?](#%D0%BA%D0%B0%D0%BA-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D1%82%D0%B8%D1%82%D1%8C-%D0%B8%D0%B7-cli)
  * [Отладка долгоиграющего приложения](#%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0-%D0%B4%D0%BE%D0%BB%D0%B3%D0%BE%D0%B8%D0%B3%D1%80%D0%B0%D1%8E%D1%89%D0%B5%D0%B3%D0%BE-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
  * [Отладка SPA приложения](#%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0-spa-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)

<!-- tocstop -->

## Проблематика

> Как снизить время разработчика на установку Xdebug?

Конфигурация Xdebug требует вмешательства в работу нескольких компонентов рабочего окружения — клиент, сервер, IDE. Разнообразие этих компонентов и их возможных сред запуска усложняет процесс конфигурации. Понимание работы Xdebug позволит снизить временные затраты на его конфигурацию для любой среды.

Данная статья содержит разделы, призванные решить обозначенную проблему. В ней содержится:

- Принцип работы Xdebug
- Универсальная конфигурация
- Интеграция с PhpStorm
- Частые проблемы

## Принцип работы

PHP приложения могут работать в двух режимах:

- web режим — обработка входящих HTTP запросов из браузера.

  Примеры работы в связке с: nginx+fpm, nginx unit

- cli режим — когда из терминала выполняется запуск.

  Примеры работы в связке с: roadrunner, phpunit, horizon

Работа Xdebug для обоих режимов имеет общий алгоритм. Но для простоты понимания будем рассматривать их отдельно.

### Web приложение

Путь HTTP запроса проходит следующим образом:

![request](./img/request.png)

> `...` означают наличие промежуточных узлов, проходящих через публичную сеть. В локальной разработке обычно отсутствуют.

В этот процесс внедряется отладка:

![request_xdebug](./img/web_xdebug.png)

Рассмотрим этот процесс подробнее:

> Клиент в контексте статьи — это хост, на котором расположен браузер, отправляющий запрос и IDE, слушающее входящие соединения от Xdebug.

1. Клиент отправляет запрос с меткой триггера, что этот запрос нужно отладить.
2. Стартует PHP скрипт, который начинает обрабатывать HTTP запрос.
3. PHP engine в стартовых хуках запускает Xdebug расширение
4. Выполняется проверка наличия триггера.
5. Происходит поиск адреса клиента.
6. Попытка установки соединения с клиентом.
7. Начало отладки: передача управления клиенту, общение и ожидания команд от клиента.
8. Окончание отладки из-за команды остановки от клиента или при завершении работы скрипта.

![session](./img/session.png)

#### Триггер

Для того чтобы инициировать Xdebug сессию, в HTTP запросе необходимо передать специальный триггер (метка). Эта метка состоит из пары ключ+значение: `XDEBUG_TRIGGER=<любое значение>` (легаси версия продолжает поддерживаться `XDEBUG_SESSION=<любое значение>`). Триггер необходимо передать одним из трех способов:

- Cookie
- Query-параметр
- Post-нагрузка

Популярное браузерное расширение [Xdebug hepler](https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc?hl=en) передает триггер через Cookie. 

> С помощью опции `xdebug.trigger_value` можно конфигурировать значение, при котором будет срабатывать триггер. По умолчанию срабатывает на любое значение.

#### Xdebug хук и Проверка триггера

Расширение Xdebug встраивается в жизненный цикл PHP. Поэтому после старта PHP engine в стартап хуке Xdebug выполняется проверка наличия триггера. В случае его отсутствия Xdebug расширение не предпринимает попыток создания сессии и PHP продолжает работать в штатном режиме.

#### Поиск адреса клиента и соединение

После положительной проверки триггера выполняется поиск адреса клиента, с котором будет установленно соединение.

> Клиентом в нашем контексте имеется ввиду, тот, кто изначально отправил HTTP запрос.

Критерием успешности выполнения этого шага является успешная установка соединения с клиентом.

Алгоритм основан на проверке всех потенциальных клиентских адресов. Сама проверка состоит из получения адреса из runtime-переменной и установки соединения с этим адресом. При успешной попытки используется это установленное соединение. При неудачной попытке происходит переход к следующему потенциальному адресу. В случае перебора всех возможных адресов происходит последняя попытка соединения с резервным адресом, указанным в конфигурации Xdebug.

Пример работы Xdebug с примененной ниже конфигурацией:

1. Соединение с адресом из HTTP заголовка `X-FORWARDED-FOR` (если используется load balancer)
2. Соединение с адресом из переменной `REMOTE_ADDR` (используется в основном)
3. (резервный) Соединение с адресом из конфигурации Xdebug (по-умолчанию `localhost`)

Если все же не удалось установить соединение ни с каким адресом, то PHP продолжает работать как обычно.

Конфигурация:

```ini
xdebug.client_discovery_header = "HTTP_X_FORWARDED_FOR,REMOTE_ADDR"
; Это переопределенное поведение. По умолчанию, оно отключено
xdebug.discover_client_host = true

; Это резервное соединение
xdebug.client_host = localhost
xdebug.client_port = 9003
```

Обратите внимание, что расширение Xdebug подключается к IDE через порт 9003.

#### Общение с клиентом

Общение между Xdebug (отладчиком) и IDE (клиентом) выполняется по протоколу [DBGp](https://xdebug.org/docs/dbgp). Задача протокола согласовать общение между отладчиком и клиентом. 

Помимо обмена техническими параметрами, необходимые для установки соединения, в процессе общения Xdebug присылает информацию, сообщающую данные о текущей остановке скрипта. Рассмотрим подробнее:

```xml
<?xml version="1.0" encoding="iso-8859-1"?>
<response xmlns="urn:debugger_protocol_v1" xmlns:xdebug="https://xdebug.org/dbgp/xdebug" command="step_over" transaction_id="17" status="break" reason="ok">
    <xdebug:message filename="file:///home/vagrant/ez-project/public/index.php" lineno="42"></xdebug:message>
</response>
```

Остановка скрипта при отладке описывается двумя значениями: название файла и номер строки. В IDE это выглядит следующим образом:

![Image](./img/xsession.png)

Эти пути отличаются друг от друга. Причина в том, что код работает в другой среде, такой как виртуальная машина или контейнер. В то же время, для IDE файлы с кодом расположены на текущем хоста. Так что одна из задач IDE — обеспечить маппинг этих путей для корректной работы с Xdebug.

#### Окончание отладки

Соединение IDE с Xdebug расширением обрывается. PHP скрипт завершает работу.

### CLI-приложение

// TODO: картинка в режиме CLI

Схема общения в отличие от web приложения практически идентична, но с небольшими отличиями:

1. Вместо передачи `XDEBUG_TRIGGER` в HTTP запросе, эта переменная должны быть передана в качестве переменной окружения.
2. Автоматический поиск адреса клиента с помощью переменных `HTTP_X_FORWARDED_FOR` и `REMOTE_ADDR` недоступен в этом режиме. Используйте `xdebug.client_host` с указанным адресом хоста

Пример запуска PHP в CLI с включенным Xdebug расширением:

```shell
XDEBUG_TRIGGER=1 php -d xdebug.client_host=<host value> script.php
```

### Проксирование

Проксирование позволяет подключение отладчика к IDE через промежуточный узел.

#### DBGp Proxy

[DBGp Proxy](https://xdebug.org/docs/dbgpProxy) — утилита, запускаемая на узле. Она позволяет частично преодолеть NAT, а также настроить отладку приложения между несколькими пользователями одновременно.

![dbgp](./img/dbgp.png)

Схема работы следующая:

1. Запускается `DBGp Proxy` утилита, который слушает 2 сокета:

    - _(server)_ Соединения от PHP engine
    - _(client)_ Соединения от IDE

    ```shell
    ./dbgpProxy --server 0.0.0.0:9003 --client 0.0.0.0:9001
    ```

2. В конфигурации PHP явно указывается адрес `DBGp Proxy` утилиты

    ```ini
    ; Отключение автообнаружения
    xdebug.discover_client_host = false
    xdebug.client_host = <адрес DBGp Proxy>
    xdebug.client_port = 9003
    ```

3. IDE отправляет запрос в `DBGp Proxy`. Этот запрос содержит ключ IDE — уникальный идентификатор для DBGp Proxy утилиты, который используется для маршрутизации Xdebug сессии нужному клиенту.

   ![dbgp_register](./img/dbgp_register.png)

4. DBGp Proxy утилита принимает запрос и регистрирует IDE (3 последних строчки):

    ```text
    ➜ ./dbgpProxy --client 0.0.0.0:9001 --server 0.0.0.0:9003
    10:00:00 [dbgpProxy] Proxy started
    10:00:00 [server] Started server server on 0.0.0.0:9003
    10:00:00 [server] Started client server on 0.0.0.0:9001
    10:00:12 [server] Start new client connection from 192.168.56.1:55708
    10:00:12 [proxyinit] [CLIENT_2] Added connection for IDE Key 'CLIENT_2': 192.168.56.1:9003
    10:00:12 [server] Closing client connection from 192.168.56.1:55708
    ```

5. Пользователь подготавливает ключ IDE на клиентской стороне и инициирует отладку HTTP запроса. К примеру, установка IDE ключа в браузерном расширении Xdebug Helper: 

   ![xdebug_helper_idekey](./img/xdebug_helper_idekey.png)

   Под капотом будет отправлена куки `XDEBUG_TRIGGER=CLIENT_2`

Теперь `DBGp Proxy` будет маршрутизировать пришедшие сессии отладки в клиентские IDE по указанному ключу из HTTP запроса.

> ⚠️ DBGp Proxy утилита устанавливает новые соединения с IDE на каждый запрос от Xdebug расширения. Это означает, ограничения сети не должны влиять на соединение между DBGp Proxy и клиентом.

#### Xdebug Cloud

[Xdebug Cloud](https://xdebug.cloud/) — коммерческий продукт. Его использование значительно упрощает процесс установки Xdebug. Более того, он позволяет устанавливать Xdebug сессии между узлами в обход NAT и фаерволов.

![xcloud](./img/xcloud.png)

Процесс установки простой:

1. Получить Cloud ID

2. Указать его в конфигурацию PHP

    ```ini
    xdebug.cloud_id = f0ec9529-184b-471c-bd20-c12b1bfa9258
    ; Следует повысить таймаут для надежного соединения
    xdebug.connect_timeout_ms = 1000
    ```

3. Указать Cloud ID в конфигурации PhpStorm

   ![xdebug_cloud](./img/xdebug_cloud.png)

Настройка завершена.

> ⚠️ Имейте ввиду! Соединение между PHP engine и Xdebug Cloud не защищено. DBGp протокол позволяет выполнение любого PHP кода. Так, что в случае man-in-the-middle атаки, злоумышленник может получить полный доступ к вашей системе ([issue link](https://github.com/xdebug/xdebug/pull/646)).

## Конфигурация

### Универсальная конфигурация Xdebug

В Интернете есть множество ответов с различным видением процесса отладки. С моей точки зрения (отладка в IDE только, когда браузерное расширение включено) только эти опции должны быть изменены, остальные должны быть нетронуты.

> Настоятельно рекомендую использовать 9003 порт. Этот порт более уникален, в отличии старого 9000 порта, который может быть занят другими процессами.

#### Local

```ini
xdebug.mode = debug

xdebug.discover_client_host = false
xdebug.client_host = localhost
xdebug.client_port = 9003
```

#### Vagrant

```ini
xdebug.mode = debug

xdebug.discover_client_host = true
xdebug.client_port = 9003
```

#### Docker

```ini
xdebug.mode = debug

xdebug.discover_client_host = false
xdebug.client_host = host.docker.internal
xdebug.client_port = 9003
```

### Особенности настройки в PhpStorm

![phpstorm_xdebug](./img/phpstorm_xdebug.png)

// TODO: нормальное объяснение — что-то вроде общей шины и работы над несколькими проектами.

Помимо выполнения основной функции управления отладкой PhpStorm решает еще две нетривиальные проблемы — поиск проекта и маппинг файлов. Сложность со стороны IDE заключается в том, что у пользователя открыто множество проектов, настроено несколько окружений (локальное, vagrant, docker, ssh). Задача IDE является соотнести пришедший на отладку запрос с запущенным проектом и выполнить маппинг локальных файлов с файлами, находящимися на удаленной машине.

Для комфортной работы разработчику необходимо выполнить обе настройки, о которых говорится далее.

#### Запуск скриптов из IDE

// TODO: картинка в запуском тестов

В этом режиме PhpStorm'у уже известен проект и его поиск не требуется. При запуске отладки необходимо указать (удаленный) интерпретатор и установить корректный маппинг:

- `Settings` — `PHP` — `CLI Interpeter` — выбрать хост с удаленной машиной ([Check Xdebug installation](https://www.jetbrains.com/help/PhpStorm/configuring-xdebug.html#integrationWithProduct))
- `Settings` — `PHP` — `Path mappings` — настроить (убедиться в наличии) соответствия путей на локальной машине и удаленной. Пример в таблице ниже

|                             |                            |
|-----------------------------|----------------------------|
| Путь на хосте               | `/Users/macos/ez-project`  |
| Путь в виртуалке/контейнере | `/home/vagrant/ez-project` |

Теперь вы сможете запускать PHP скрипты из IDE, например запуск PHPUnit тестов:

// TODO: картинка

#### Обработка запросов пришедших в IDE

В этом режиме PhpStorm'у неизвестен ни проект, ни маппинг. IDE в этом случае сначала выполняет поиск проекта по следующему алгоритму:

1. IDE принимает соединение
2. IDE вычисляет идентификатор соединения. По DBGp протоколу PhpStorm вычисляет значения:

   - `$_SERVER['PHP_IDE_CONFIG']`

      Пример: `serverName=laradock`

   - `$_SERVER['SERVER_NAME']`

      Пример: `ez-project.test`

   - `$_SERVER['SSH_CONNECTION']`

      Пример: `10.0.2.2 53511 10.0.2.15 22`

3. IDE ищет проект, в который необходимо маршрутизировать соединение

   - Если `$_SERVER['PHP_IDE_CONFIG']` установлен, то выполняется поиск `Server` по его `Name`

     ![laradock](./img/laradock.png)

   - Если `$_SERVER['SERVER_NAME']` или `$_SERVER['SSH_CONNECTION']` установлены, то выполняется поиск `Server` по его `Host` и `Port`

     ![host_port](./img/host_port.png)

   - Если ни одна из переменных не установлена, то IDE не сможет идентифицировать соединение

      ![none](./img/none.png)

4. Если проект не найден, то IDE предложит вручную выполнить маршрутизацию в проект

// TODO: картинка ручного выбора проекта

// TODO: примечание, что для Docker'а обычно используется — PHP_IDE_CONFIG, а для vagrant — SSH_CONNECTION

**Для того чтобы настроить конфигурацию, необходимо:**

1. Выполнить первый HTTP запрос с включенным дебагом
2. Выбрать предложенный IDE проект и файл
3. Зайти в `Settings` — `Servers` — Выбрать созданный `Server`
4. Выбрать `Use path mappings`
5. Напротив пути к локальному пути прописать путь к проекту в виртуалке/контейнере

|                             |                                     |
|-----------------------------|-------------------------------------|
| Путь на хосте               | `/Users/macos/projects/ez-project`  |
| Путь в виртуалке/контейнере | `/home/vagrant/projects/ez-project` |

## Частые проблемы

### Как инспектировать?

1. Проверить, что для CLI и FPM режимов Xdebug подключен

    ```shell
    php -v
    ->    with Xdebug v3.2.1, Copyright (c) 2002-2023, by Derick Rethans

    php-fpm8.2 -v
    ->    with Xdebug v3.2.1, Copyright (c) 2002-2023, by Derick Rethans
    ```

2. Если расширение отсутствует, то попробовать установить через:

    ```shell
    # Включение
    phpenmod xdebug
    # Обязательна перезагрузка fpm после включения
    sudo systemctl restart php-fpm
    # Возможна вариация
    sudo systemctl restart php8.2-fpm
    ```

    Либо `pecl`, либо любые другие способы из Интернета

3. Проверить конфигурацию для CLI и FPM режимов, что она совпадает с [Универсальная конфигурация Xdebug](#Универсальная конфигурация Xdebug)

    ```shell
    php -i | grep xdebug

    php-fpm -i | grep xdebug
    ```

// TODO: поиск файла с конфой
4. Если заявленная конфигурация отличается от фактической, возможно в папке `conf.d` могут содержаться несколько конфигураций Xdebug. Приоритет конфигураций над последним загруженным.

    Также имена конфигурационных файлов могут содержать числа-префиксы, необходимые для указания порядка загрузки (сравнение строк по символам ASCII). Приоритет для двух файлов `20-xdebug.ini` и `xdebug.ini` будет:

   - `20-xdebug.ini`
   - `xdebug.ini` — директивы из ранее загруженных файлов будут переопределены

5. Если Xdebug не соединяется с IDE, то проинспектировать логи:

    - Включить логи, добавив в `xdebug.ini`:

      ```ini
      xdebug.log = /var/log/xdebug.log
      ```

    - Добавить файл с логом и правами

      ```shell
      sudo touch /var/log/xdebug.log
      sudo chmod 666 /var/log/xdebug.log
      ```

// TODO: inspect xdebug in IDE

6. Остальные проблемы см. официальной документации [Troubleshooting common PHP debugging issues](https://www.jetbrains.com/help/PhpStorm/troubleshooting-php-debugging.html) либо гугл.

### Cannot find file '/var/www/ez-project/index.php' locally

> Cannot find file '/var/www/ez-project/index.php' locally.
> To fix it set server name by environment variable PHP_IDE_CONFIG and restart debug session.

Убедиться в наличии одной из переменных из раздела [Обработка запросов пришедших в IDE](./Обработка запросов пришедших в IDE)

### Как запустить из CLI?

Для запуска из CLI необходимо убедиться, что адрес IDE будет определен верно. В случае с универсальной конфигурацией для локальной машины и docker-окружения необходимо запустить:

```shell
XDEBUG_TRIGGER=1 php artisan tests

# При необходимости передать конфиг, по которому будет идентифицирован сервер
PHP_IDE_CONFIG='serverName=SomeName' XDEBUG_TRIGGER=1 php artisan tests
```

Для Vagrant используйте:

```shell
XDEBUG_TRIGGER=1 php -d xdebug.client_host=10.0.2.2 artisan tests
```

### Отладка долгоиграющего приложения

Отладка долгоиграющего приложения усложняется, если оно порождает воркеров. Для отладки кода, исполняемого воркером, используйте:

1. В начале кода, который необходимо отладить, вызовите функцию:

    ```php
    xdebug_connect_to_client();
    ```

2. Запустите долгоиграющее приложение со специальным флагом:

   ```shell
   php -d xdebug.start_with_request=no artisan horizon
   ```

### Отладка SPA приложения

Работа с SPA приложением подразумевает расположение фронтенд и бэкенд приложений на разных адресах. В этом случае при работе клиентского приложения, браузерное расширение [Xdebug Helper](https://chrome.google.com/webstore/detail/xdebug-helper/eadndfjplgieldjbigjakmdgkmoaaaoc) не будет отправлять триггер отладки при отправке запроса на бэкенд. Решение заключается в расположении фронтенд и бэкенд приложений на одном адресе:

1. Необходимо в конфигурации веб-сервера, который отдает фронтенд, внести правки:

    В случае, если используется webpack, то в `webpack.config.js`:

    ```javascript
    module.exports = {
      devServer: {
        proxy: {
          '/api': {
            target: `${process.env.BACKEND_URL}`,
            changeOrigin: true,
            xfwd: false,
          },
        },
      ...
    ```

   В случае, если используется vite, то в `vite.config.js`

    ```javascript
    export default defineConfig({
      server: {
        proxy: {
          '/api': {
            target: `${process.env.BACKEND_URL}`,
            changeOrigin: true,
            xfwd: false,
          },
        },
     ...
    ```

2. В клиентском приложении переопределить адрес бэкенда на адрес фронтенда (обычно что-то вроде изменения переменной `BACKEND_URL` в `.env.local`).

Теперь все запросы с префиксом `/api` будут проксироваться на бэкенд, заголовок `Cookie` с меткой триггера тоже будет передан.

**Альтернативный вариант:**

1. В DevTools во вкладке `Networks` найти запрос для отладки
2. Скопировать его как `copy as cURL`
3. Вставить в терминал и добавить к нему `-H 'Cookie: XDEBUG_TRIGGER=1`
4. Отправить запрос
